//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

public class Pass2<R,A> implements GJVisitor<R,A> {
   // public class EncodeData {
   //    public HashMap<String, HashMap<Integer, String>> allocation;
   //    public HashMap<String, HashMap<Integer, Integer>> spills;
   //    public HashMap<String, Integer> max_args_used;
   //    public HashMap<String, HashMap<String, String>> label_map;
   // }

   public class Pair<T1, T2> {
      public Pair(T1 x, T2 y) {
         first=x;
         second=y;
      }
      public String toString() {
         return "(" + first + ", " + second + ")";
      }

      public T1 first;
      public T2 second;
   }

   HashMap<String, HashMap<Integer, Pair<Integer, Integer>>> function_live_intervals=new HashMap<>();
   HashMap<String, HashMap<Integer, String>> allocation=new HashMap<>();
   HashMap<String, HashMap<Integer, Integer>> spills=new HashMap<>();

   void sort_intervals_by_start(ArrayList<Pair<Integer, Pair<Integer, Integer>>> intervals) {
      Collections.sort(intervals, new Comparator<Pair<Integer, Pair<Integer, Integer>>>() {
         public int compare(Pair<Integer, Pair<Integer, Integer>> a1, Pair<Integer, Pair<Integer, Integer>> a2) {
            return a1.second.first.compareTo(a2.second.first);
         }
      });
   }

   void sort_intervals_by_end(ArrayList<Pair<Integer, Pair<Integer, Integer>>> intervals) {
      Collections.sort(intervals, new Comparator<Pair<Integer, Pair<Integer, Integer>>>() {
         public int compare(Pair<Integer, Pair<Integer, Integer>> a1, Pair<Integer, Pair<Integer, Integer>> a2) {
            return a1.second.second.compareTo(a2.second.second);
         }
      });
   }

   void allocate_registers() {
      for(String proc_name: function_live_intervals.keySet()) {
         HashMap<Integer, Pair<Integer, Integer>> intervals=new HashMap(function_live_intervals.get(proc_name));
         ArrayList<Pair<Integer, Pair<Integer, Integer>>> live_intervals=new ArrayList<>();
         for(Integer temp_number: intervals.keySet()) {
            Pair<Integer, Integer> range=intervals.get(temp_number);
            Pair<Integer, Integer> range_copy=new Pair<Integer, Integer>(range.first, range.second);
            live_intervals.add(new Pair<Integer, Pair<Integer, Integer>>(temp_number, range_copy));
         }
         sort_intervals_by_start(live_intervals);
         Pair<HashMap<Integer, String>, HashMap<Integer, Integer>> allocation_and_spills=linear_scan_register_allocation(proc_name, live_intervals);
         allocation.put(proc_name, new HashMap<Integer, String>(allocation_and_spills.first));
         spills.put(proc_name, new HashMap<Integer, Integer>(allocation_and_spills.second));
      }
   }

   Pair<HashMap<Integer, String>, HashMap<Integer, Integer>> linear_scan_register_allocation(String proc_name, ArrayList<Pair<Integer, Pair<Integer, Integer>>> live_intervals) {
      String general_registers[] = { "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7", "t8", "t9" };
      Set<String> free_registers = new TreeSet<>(Arrays.asList(general_registers));

      HashMap<Integer, String> register=new HashMap<>();
      HashMap<Integer, Integer> location=new HashMap<>();
      Integer stack_counter=Math.max(arg_count.get(proc_name) - 4, 0);

      ArrayList<Pair<Integer, Pair<Integer, Integer>>> active=new ArrayList<>();
      for(Pair<Integer, Pair<Integer, Integer>> interval: live_intervals) {
         expire_old_intervals(active, free_registers, register, interval);
         if(active.size() == general_registers.length) {
            spill_at_interval(active, register, location, interval, stack_counter++);
         } else {
            String plucked_register=free_registers.iterator().next();
            free_registers.remove(plucked_register);
            register.put(interval.first, plucked_register);
            active.add(interval);
            sort_intervals_by_end(active);
         }
      }
      return new Pair<HashMap<Integer, String>, HashMap<Integer, Integer>>(register, location);
   }

   void expire_old_intervals(ArrayList<Pair<Integer, Pair<Integer, Integer>>> active, Set<String> free_registers, HashMap<Integer, String> register, Pair<Integer, Pair<Integer, Integer>> interval) {
      while(active.size() > 0) {
         Integer temp_number=active.get(0).first;
         if(active.get(0).second.second >= interval.second.first)
            return;
         free_registers.add(register.get(temp_number));
         active.remove(0);
      }
   }

   void spill_at_interval(ArrayList<Pair<Integer, Pair<Integer, Integer>>> active, HashMap<Integer, String> register, HashMap<Integer, Integer> location, Pair<Integer, Pair<Integer, Integer>> interval, Integer stack_location) {
      Pair<Integer, Pair<Integer, Integer>> spill=active.get(active.size()-1);
      if(spill.second.second > interval.second.second) {
         register.put(interval.first, register.get(spill.first));
         register.remove(spill.first);
         location.put(spill.first, stack_location);
         active.remove(active.size()-1);
         active.add(interval);
         sort_intervals_by_end(active);
      } else {
         location.put(interval.first, stack_location);
      }
   }

   HashMap<String, HashMap<Integer, Set<Integer>>> use=new HashMap<>();
   HashMap<String, HashMap<Integer, Set<Integer>>> def=new HashMap<>();
   HashMap<String, HashMap<Integer, Set<Integer>>> succ=new HashMap<>();
   HashMap<String, HashMap<Integer, Set<Integer>>> livein=new HashMap<>();
   HashMap<String, HashMap<Integer, Set<Integer>>> liveout=new HashMap<>();

   HashMap<String, HashMap<String, Integer>> label;
   HashMap<String, Integer> arg_count=new HashMap<>();

   Integer label_number=0;
   HashMap<String, HashMap<String, String>> label_map=new HashMap<>();

   Integer args_used;
   HashMap<String, Integer> max_args_used=new HashMap<>();

   String procedure_name;
   Integer statement_number;

   boolean in_arg_list=false;
   boolean in_simple_exp=false;

   void increment_statement_number() {
      statement_number++;
      use.computeIfAbsent(procedure_name, x -> new HashMap<>());
      use.get(procedure_name).computeIfAbsent(statement_number, x -> new HashSet<>());
      def.computeIfAbsent(procedure_name, x -> new HashMap<>());
      def.get(procedure_name).computeIfAbsent(statement_number, x -> new HashSet<>());
      succ.computeIfAbsent(procedure_name, x -> new HashMap<>());
      succ.get(procedure_name).computeIfAbsent(statement_number, x -> new HashSet<>());
      livein.computeIfAbsent(procedure_name, x -> new HashMap<>());
      livein.get(procedure_name).computeIfAbsent(statement_number, x -> new HashSet<>());
      liveout.computeIfAbsent(procedure_name, x -> new HashMap<>());
      liveout.get(procedure_name).computeIfAbsent(statement_number, x -> new HashSet<>());
   }

   void calculate_live_intervals() {
      for(String proc_name: livein.keySet()) {
         boolean updated;
         do {
            updated=false;
            for(Integer local_stmt: def.get(proc_name).keySet()) {
               Set<Integer> old_in=new HashSet<>(livein.get(proc_name).get(local_stmt));
               Set<Integer> new_in=new HashSet<>(liveout.get(proc_name).get(local_stmt));
               new_in.removeAll(def.get(proc_name).get(local_stmt));
               new_in.addAll(use.get(proc_name).get(local_stmt));
               livein.get(proc_name).put(local_stmt, new_in);

               Set<Integer> old_out=new HashSet<>(liveout.get(proc_name).get(local_stmt));
               Set<Integer> new_out=new HashSet<>();
               for(Integer successor: succ.get(proc_name).get(local_stmt))
                  new_out.addAll(livein.get(proc_name).get(successor));
               liveout.get(proc_name).put(local_stmt, new_out);

               if((!old_in.equals(new_in)) || (!old_out.equals(new_out)))
                  updated=true;
            }
         } while(updated);

         function_live_intervals.computeIfAbsent(proc_name, x -> new HashMap<>());
         for(Integer local_stmt: livein.get(proc_name).keySet()) {
            for(Integer temp_number: livein.get(proc_name).get(local_stmt)) {
               function_live_intervals.get(proc_name).computeIfAbsent(temp_number, x -> new Pair<Integer, Integer>(local_stmt, local_stmt));
               Pair<Integer, Integer> range=function_live_intervals.get(proc_name).get(temp_number);
               range.first=Math.min(range.first, local_stmt);
               range.second=Math.max(range.second, local_stmt);
               function_live_intervals.get(proc_name).put(temp_number, range);
            }
         }
         for(Integer local_stmt: liveout.get(proc_name).keySet()) {
            for(Integer temp_number: liveout.get(proc_name).get(local_stmt)) {
               function_live_intervals.get(proc_name).computeIfAbsent(temp_number, x -> new Pair<Integer, Integer>(local_stmt, local_stmt));
               Pair<Integer, Integer> range=function_live_intervals.get(proc_name).get(temp_number);
               range.first=Math.min(range.first, local_stmt);
               range.second=Math.max(range.second, local_stmt);
               function_live_intervals.get(proc_name).put(temp_number, range);
            }
         }

         // System.out.println("PROCEDURE: " + proc_name);
         // System.out.println("USE: " + use.get(proc_name));
         // System.out.println("DEF: " + def.get(proc_name));
         // System.out.println("SUCC: " + succ.get(proc_name));
         // System.out.println("IN: " + livein.get(proc_name));
         // System.out.println("OUT: " + liveout.get(proc_name));
         // System.out.println();
      }
   }

   //#region
   // Auto class visitors--probably don't need to be overridden.
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() ) {
         String label_name=(String)n.node.accept(this,argu);
         label_number++;
         label_map.computeIfAbsent(procedure_name, x -> new HashMap<>());
         label_map.get(procedure_name).put(label_name, "LABEL" + label_number);
         return (R) label_name;
      } else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R) n.tokenImage; }
   //#endregion

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;

      label=(HashMap<String, HashMap<String, Integer>>)argu;
      argu=null;

      procedure_name=(String) n.f0.accept(this, argu);

      arg_count.put("MAIN", 0);
      statement_number=0;
      max_args_used.put("MAIN", 0);

      n.f1.accept(this, argu);

      increment_statement_number();

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      calculate_live_intervals();
      allocate_registers();

      // System.out.println(allocation);
      // System.out.println(spills);
      // System.out.println(max_args_used);
      // System.out.println(label_map);

      EncodeData info=new EncodeData();
      info.allocation=new HashMap<>(allocation);
      info.spills=new HashMap<>(spills);
      info.max_args_used=new HashMap<>(max_args_used);
      info.label_map=new HashMap<>(label_map);

      return (R) info;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;

      procedure_name=(String)n.f0.accept(this, argu);

      statement_number=0;
      max_args_used.put(procedure_name, -1);
      n.f1.accept(this, argu);
      Integer number_of_args=Integer.parseInt((String)n.f2.accept(this, argu));
      n.f3.accept(this, argu);

      arg_count.put(procedure_name, number_of_args);

      for(Integer i=0; i<number_of_args; i++) {
         increment_statement_number();
         def.get(procedure_name).get(statement_number).add(i);
         use.get(procedure_name).computeIfAbsent(statement_number + 1, x -> new HashSet<>());
         use.get(procedure_name).get(statement_number + 1).add(i);
         succ.get(procedure_name).get(statement_number).add(statement_number + 1);
      }

      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;

      increment_statement_number();

      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);

      succ.get(procedure_name).get(statement_number).add(statement_number + 1);

      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);

      succ.get(procedure_name).get(statement_number).add(statement_number + 1);

      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer condition=Integer.parseInt((String)n.f1.accept(this, argu));
      String label_name=(String)n.f2.accept(this, argu);

      use.get(procedure_name).get(statement_number).add(condition);
      succ.get(procedure_name).get(statement_number).add(statement_number + 1);
      succ.get(procedure_name).get(statement_number).add(label.get(procedure_name).get(label_name));

      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String label_name=(String)n.f1.accept(this, argu);

      succ.get(procedure_name).get(statement_number).add(label.get(procedure_name).get(label_name));

      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer mem_location=Integer.parseInt((String)n.f1.accept(this, argu));
      n.f2.accept(this, argu);
      Integer value=Integer.parseInt((String)n.f3.accept(this, argu));

      use.get(procedure_name).get(statement_number).add(mem_location);
      use.get(procedure_name).get(statement_number).add(value);
      succ.get(procedure_name).get(statement_number).add(statement_number + 1);

      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer reg=Integer.parseInt((String)n.f1.accept(this, argu));
      Integer mem_location=Integer.parseInt((String)n.f2.accept(this, argu));
      n.f3.accept(this, argu);

      def.get(procedure_name).get(statement_number).add(reg);
      use.get(procedure_name).computeIfAbsent(statement_number + 1, x -> new HashSet<>());
      use.get(procedure_name).get(statement_number + 1).add(reg);
      use.get(procedure_name).get(statement_number).add(mem_location);
      succ.get(procedure_name).get(statement_number).add(statement_number + 1);

      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer reg=Integer.parseInt((String)n.f1.accept(this, argu));
      n.f2.accept(this, argu);

      def.get(procedure_name).get(statement_number).add(reg);
      use.get(procedure_name).computeIfAbsent(statement_number + 1, x -> new HashSet<>());
      use.get(procedure_name).get(statement_number + 1).add(reg);
      succ.get(procedure_name).get(statement_number).add(statement_number + 1);

      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      succ.get(procedure_name).get(statement_number).add(statement_number + 1);

      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      increment_statement_number();

      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      in_arg_list=true;
      args_used=0;
      n.f3.accept(this, argu);
      max_args_used.put(procedure_name, Math.max(args_used, max_args_used.get(procedure_name)));
      in_arg_list=false;

      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      Integer first_op=Integer.parseInt((String)n.f1.accept(this, argu));
      n.f2.accept(this, argu);

      use.get(procedure_name).get(statement_number).add(first_op);

      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;

      in_simple_exp=true;
      n.f0.accept(this, argu);
      in_simple_exp=false;

      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret=n.f1.accept(this, argu);

      if(in_arg_list || in_simple_exp) {
         Integer temp_number=Integer.parseInt((String)_ret);
         use.get(procedure_name).get(statement_number).add(temp_number);

         if(in_arg_list) args_used++;
      }

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret=n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      _ret=n.f0.accept(this, argu);

      return _ret;
   }

}
