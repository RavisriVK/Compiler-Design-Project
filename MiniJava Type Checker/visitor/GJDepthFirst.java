//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;

/*
{
type_error=true;
;
;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);;
}

{
;
;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "--" + argu);;
return _ret;
}
*/

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   /**
    * In MiniJava, variable declarations happen only at the beginning of classes and methods.
    * Other accessible variables are function parameters.
    * Since there are only two types of scopes, we can store the solution for both directly.
    */

   public static class function_signature {
      String method_name="";
      String access_type="";
      String return_type="";
      ArrayList<String> parameter_list=new ArrayList<String>();
   }

   public static class method_details {
      String access_type="";
      String return_type="";
      ArrayList<String> parameter_list=new ArrayList<String>();
      Hashtable<String, String> arguments=new Hashtable<String, String>();
      Hashtable<String, String> local_variables=new Hashtable<String, String>();
   }

   public static class class_details {
      String parent_class="";
      Hashtable<String, String> class_variables=new Hashtable<String, String>();
      Hashtable<String, method_details> methods=new Hashtable<String, method_details>();
   }

   /* Symbol Table */
   static Hashtable<String, class_details> classes=new Hashtable<String, class_details>();

   String get_variable_type(String variable_name, String class_and_method) {
      if(type_error) return null;
      if(class_and_method==null) {
         implementation_error=true;
         return null;
      }

      String[] parts=class_and_method.split("\\s+");
      if(parts.length!=2) {
         implementation_error=true;
         return null;
      }
      String class_name=parts[0];
      String method_name=parts[1];

      if(!classes.containsKey(class_name)) {
         type_error=true;
         ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->");
         return null;
      }
      class_details selected_class=classes.get(class_name);

      if(!selected_class.methods.containsKey(method_name)) {
         type_error=true;
         ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->");
         return null;
      }
      method_details selected_method=selected_class.methods.get(method_name);

      if(selected_method.local_variables.containsKey(variable_name))
         return selected_method.local_variables.get(variable_name);
      if(selected_method.arguments.containsKey(variable_name))
         return selected_method.arguments.get(variable_name);

      String current_class=class_name;
      while(current_class.compareTo("")!=0) {
         if(classes.get(current_class).class_variables.containsKey(variable_name))
            return classes.get(current_class).class_variables.get(variable_name);
         current_class=classes.get(current_class).parent_class;
      }

      type_error=true;
      ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->");
      return null;
   }

   boolean is_descendent_of(String type1, String type2) {
      if(type_error) return false;
      if(!classes.containsKey(type1) || !classes.containsKey(type2)) {
         return type1.compareTo(type2)==0;
      }

      String class_name=type1;
      while(class_name.compareTo("")!=0) {
         if(type2.compareTo(class_name)==0)
            return true;
         class_name=classes.get(class_name).parent_class;
      }
      return false;
   }

   String least_upper_bound(String type1, String type2) {
      if(type_error) return null;
      if(!classes.containsKey(type1) || !classes.containsKey(type2)) {
         if(type1.compareTo(type2)==0) {
            return type1;
         } else {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->");
            return null;
         }
      }

      Set<String> ancestor_set1=new HashSet<>();
      String class_name=type1;
      while(class_name.compareTo("")!=0) {
         ancestor_set1.add(class_name);
         class_name=classes.get(class_name).parent_class;
      }
      class_name=type2;
      while(class_name.compareTo("")!=0) {
         if(ancestor_set1.contains(class_name))
            return class_name;
         class_name=classes.get(class_name).parent_class;
      }

      type_error=true;
      ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->");
      return null;
   }

   boolean no_overloading(function_signature signature, String class_name) {
      String current_class=class_name;
      String method_name=signature.method_name;

      while(current_class.compareTo("")!=0) {
         class_details selected_class=classes.get(current_class);
         if(selected_class.methods.containsKey(method_name)) {
            method_details selected_method=selected_class.methods.get(method_name);
            if(signature.access_type.compareTo(selected_method.access_type)!=0 || signature.return_type.compareTo(selected_method.return_type)!=0 || !signature.parameter_list.equals(selected_method.parameter_list)) {
               return false;
            }
         }
         current_class=classes.get(current_class).parent_class;
      }

      return true;
   }

   function_signature get_function_signature(String method_name, String class_name) {
      if(type_error) return null;
      String current_class=class_name;
      while(current_class.compareTo("")!=0) {
         class_details selected_class=classes.get(current_class);
         if(selected_class.methods.containsKey(method_name)) {
            method_details selected_method=selected_class.methods.get(method_name);
            if(current_class.compareTo(class_name)==0 || selected_method.access_type.compareTo(PUBLIC)==0 || selected_method.access_type.compareTo(PROTECTED)==0) {
               function_signature signature=new function_signature();
               signature.access_type=selected_method.access_type;
               signature.return_type=selected_method.return_type;
               signature.parameter_list=new ArrayList<String>(selected_method.parameter_list);
               return signature;
            }
         }
         current_class=classes.get(current_class).parent_class;
      }

      type_error=true;
      ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->");
      return null;
   }

   /* Phase */
   public static final String CONSTRUCT_SYMBOL_TABLE="construct_symbol_table";
   public static final String PARSE_AND_TYPE_CHECK="parse_and_type_check";
   static String phase;

   /* Types */
   public static final String INT_TYPE="int";
   public static final String BOOLEAN_TYPE="boolean";
   public static final String INT_ARRAY_TYPE="int[]";

   /* Access Specifiers */
   public static final String PUBLIC="public";
   public static final String PROTECTED="protected";
   public static final String PRIVATE="private";

   /* Errors */
   boolean type_error=false;
   boolean implementation_error=false;

   /* Expression List */
   static ArrayList<String> expression_list=new ArrayList<String>();
   boolean in_expression_list=false;

   public R visit(NodeList n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         if(type_error) return null;
         Method mt = new Object(){}.getClass().getEnclosingMethod();
         ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
         R _ret=null;

         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R) n.tokenImage; }

   //
   // Visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      phase=(String)argu;
      argu=null;

      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         if(type_error) {
            ;// System.out.println("Type error");
            return _ret;
         }

         Set<String> class_name_set=classes.keySet();
         for(String class_name: class_name_set) {
            class_details selected_class=classes.get(class_name);
            ;// System.out.println(class_name);
            ;// System.out.println(selected_class.parent_class);
            Set<String> variable_declaration_set=selected_class.class_variables.keySet();
            for(String variable_name: variable_declaration_set) {
               ;// System.out.println("[" + variable_name + "] " + selected_class.class_variables.get(variable_name));
            }
            Set<String> method_declaration_set=selected_class.methods.keySet();
            for(String method_name: method_declaration_set) {
               method_details selected_method=selected_class.methods.get(method_name);
               ;// System.out.println("[" + method_name + "] " + selected_method.access_type + " " + selected_method.return_type + " " + selected_method.parameter_list.toString());
               ;// System.out.println(selected_method.local_variables.toString());
            }
         }

         for(String class_name: class_name_set) {
            class_details selected_class=classes.get(class_name);
            Set<String> method_declaration_set=selected_class.methods.keySet();
            for(String method_name: method_declaration_set) {
               method_details selected_method=selected_class.methods.get(method_name);
               function_signature signature=new function_signature();
               signature.method_name=method_name;
               signature.access_type=selected_method.access_type;
               signature.return_type=selected_method.return_type;
               signature.parameter_list=selected_method.parameter_list;

               if(!no_overloading(signature, class_name)) {
                  type_error=true;
                  return _ret;
               }
            }
         }
      }

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(!type_error)
            System . out . println("Program type checked successfully");
         else
            System . out . println("Type error");
      }

      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      String class_name=(String)n.f1.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         /* Ensure distinct class names */
         if(classes.containsKey(class_name)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
         }

         class_details main_class=new class_details();
         method_details main_function=new method_details();
         main_function.access_type="public";
         main_function.return_type="void";
         main_class.methods.put("main", main_function);
         classes.put(class_name, main_class);
      }

      argu=(A)(class_name + " " + "main");
      n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;
      n.f5.accept(this, argu); if(type_error) return null;
      n.f6.accept(this, argu); if(type_error) return null;
      n.f7.accept(this, argu); if(type_error) return null;
      n.f8.accept(this, argu); if(type_error) return null;
      n.f9.accept(this, argu); if(type_error) return null;
      n.f10.accept(this, argu); if(type_error) return null;

      /* argu only has two components - not asking for type */
      n.f11.accept(this, argu); if(type_error) return null;

      n.f12.accept(this, argu); if(type_error) return null;
      n.f13.accept(this, argu); if(type_error) return null;

      /* argu passes on context of scope: class and method */
      n.f14.accept(this, argu); if(type_error) return null;

      n.f15.accept(this, argu); if(type_error) return null;
      n.f16.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      String class_name=(String)n.f1.accept(this, argu); if(type_error) return null;
      
      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         class_details temp=new class_details();

         /* Ensure distinct class names */
         if(classes.containsKey(class_name)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }

         classes.put(class_name, temp);
      }

      argu=(A)class_name;
      n.f2.accept(this, argu); if(type_error) return null;

      /* The context of class is passed on to variable declarations and method declarations */
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;

      n.f5.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      String class_name=(String)n.f1.accept(this, argu); if(type_error) return null;
      n.f2.accept(this, argu); if(type_error) return null;
      String parent_class_name=(String)n.f3.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(!classes.containsKey(parent_class_name)) {
            type_error=true;
            ;// System.out.println("parent_class: " + parent_class_name);
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         class_details temp=new class_details();
         temp.parent_class=parent_class_name;

         /* Ensure distinct class names */
         if(classes.containsKey(class_name)){
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }

         classes.put(class_name, temp);
      }

      argu=(A)class_name;
      n.f4.accept(this, argu); if(type_error) return null;

      /* The context of class is passed on to variable declarations and method declarations */
      n.f5.accept(this, argu); if(type_error) return null;
      n.f6.accept(this, argu); if(type_error) return null;

      n.f7.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String data_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      String variable_name=(String)n.f1.accept(this, argu); if(type_error) return null;
      n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         String[] parts=((String)argu).split("\\s+");
         String class_name=parts[0];
         if(parts.length==1) {
            classes.get(class_name).class_variables.put(variable_name, data_type);
         } else {
            String method_name=parts[1];
            method_details selected_method=classes.get(class_name).methods.get(method_name);

            /* Ensure distinct local variable names within a method */
            if(selected_method.local_variables.containsKey(variable_name)) {
               type_error=true;
               ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
               return null;
            }

            selected_method.local_variables.put(variable_name, data_type);
         }
      }

      return _ret;
   }

   /**
    * f0 -> AccessType()
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String class_name=(String)argu;

      String access_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      String return_type=(String)n.f1.accept(this, argu); if(type_error) return null;
      String function_name=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         method_details temp=new method_details();
         temp.access_type=new String(access_type);
         temp.return_type=new String(return_type);
         class_details selected_class=classes.get(class_name);

         /* Ensure distinct method names within a class */
         if(selected_class.methods.containsKey(function_name)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }

         selected_class.methods.put(function_name, temp);
      }

      argu=(A) (class_name + " " + function_name);

      /* Pass on class and method context */
      n.f4.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         ;// System.out.println(argu);
         method_details selected_method=classes.get(class_name).methods.get(function_name);

         function_signature signature=new function_signature();
         signature.method_name=function_name;
         signature.access_type=access_type;
         signature.return_type=return_type;
         signature.parameter_list=new ArrayList<String>(selected_method.parameter_list);
      }
      
      n.f5.accept(this, argu); if(type_error) return null;
      n.f6.accept(this, argu); if(type_error) return null;

      /* Pass on class and method context */
      n.f7.accept(this, argu); if(type_error) return null;
      n.f8.accept(this, argu); if(type_error) return null;

      n.f9.accept(this, argu); if(type_error) return null;

      /* Pass on class and method context */
      String expression_type=(String)n.f10.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(!is_descendent_of(expression_type, return_type)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      n.f11.accept(this, argu); if(type_error) return null;
      n.f12.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String data_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      String variable_name=(String)n.f1.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(CONSTRUCT_SYMBOL_TABLE)==0) {
         String[] parts=((String)argu).split("\\s+");
         String class_name=parts[0];
         String method_name=parts[1];
         method_details selected_method=classes.get(class_name).methods.get(method_name);

         /* Ensure distinct argument names for a method */
         if(selected_method.arguments.containsKey(variable_name)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }

         selected_method.parameter_list.add(data_type);
         selected_method.arguments.put(variable_name, data_type);
      }

      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> PublicType()
    *       | PrivateType()
    *       | ProtectedType()
    */
   public R visit(AccessType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String array_type="";
      array_type+=(String)n.f0.accept(this, argu); if(type_error) return null;
      array_type+=(String)n.f1.accept(this, argu); if(type_error) return null;
      array_type+=(String)n.f2.accept(this, argu); if(type_error) return null;

      return (R) array_type;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "public"
    */
   public R visit(PublicType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "private"
    */
   public R visit(PrivateType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "protected"
    */
   public R visit(ProtectedType n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(expression_list.size() > 0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(expression_list);
            return null;
         }
      }

      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      n.f2.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      /* We want type of identifier - if argu not already of variable type, add variable_type */
      if(((String)argu).split("\\s+").length<3)
         argu=(A) (((String)argu)+" variable_type");
      
      String assignee_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String expression_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         ;// System.out.println(expression_type + "-" + assignee_type);
         if(!is_descendent_of(expression_type, assignee_type)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(assignee_type + "- " + expression_type);
            return null;  
         }
      }

      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;


      /* We want type of identifier - if argu not already of variable type, add variable_type */
      if(argu==null || ((String)argu).split("\\s+").length<3)
         argu=(A)(((String)argu) + " variable_type");

      String array_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String index_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;
      String expression_type=(String)n.f5.accept(this, argu); if(type_error) return null;
      n.f6.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(array_type.compareTo(INT_ARRAY_TYPE)!=0 || index_type.compareTo(INT_TYPE)!=0 || expression_type.compareTo(INT_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(array_type + "-" + index_type + "-" + expression_type);
            return null;
         }
      }

      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String condition_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(condition_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }
      
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String condition_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;
      n.f5.accept(this, argu); if(type_error) return null;
      n.f6.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         ;// System.out.println("()"+condition_type);
         if(condition_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String condition_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(condition_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return _ret;
   }

   /**
    * f0 -> ";// System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String expression_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(expression_type.compareTo(INT_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(expression_type);
            return null;
         }
      }

      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | TernaryExpression()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      if(type_error) return null;
      boolean add_to_expression_list=false;
      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0 && argu!=null) {
         String[] parts=((String)argu).split("\\s+");
         ;// System.out.println(argu);
         if(parts[parts.length-1].compareTo("add_to_expression_list")==0) {
            add_to_expression_list=true;
            String new_argu="";
            for(int i=0; i<parts.length-1; i++)
               new_argu=new_argu + parts[i] + " ";
            argu=(A) new_argu;
         }
      }

      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;

      if(add_to_expression_list) {
         expression_list.add((String)_ret);
      }

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of same type */
         if(operand1_type.compareTo(BOOLEAN_TYPE)!=0 || operand2_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) BOOLEAN_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public R visit(OrExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of same type */
         if(operand1_type.compareTo(BOOLEAN_TYPE)!=0 || operand2_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) BOOLEAN_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of same type */
         if(operand1_type.compareTo(INT_TYPE)!=0 || operand2_type.compareTo(INT_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(operand1_type + "-" + operand2_type);
            return null;
         }
      }

      return (R) BOOLEAN_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public R visit(neqExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of same type */
         if(operand1_type.compareTo(operand2_type)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) BOOLEAN_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of int type */
         if(operand1_type.compareTo(INT_TYPE)!=0 || operand2_type.compareTo(INT_TYPE)!=0){
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) INT_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of int type */
         if(operand1_type.compareTo(INT_TYPE)!=0 || operand2_type.compareTo(INT_TYPE)!=0){
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) INT_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of int type */
         if(operand1_type.compareTo(INT_TYPE)!=0 || operand2_type.compareTo(INT_TYPE)!=0){
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) INT_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public R visit(DivExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String operand1_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String operand2_type=(String)n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that both operands are of int type */
         if(operand1_type.compareTo(INT_TYPE)!=0 || operand2_type.compareTo(INT_TYPE)!=0){
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) INT_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String identifier_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String index_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* ensure type(PE1) is int[], type(PE2) is int */
         if(identifier_type.compareTo(INT_ARRAY_TYPE)!=0 || index_type.compareTo(INT_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) INT_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String array_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      n.f2.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* ensure type(PE) is int[] */
         if(array_type.compareTo(INT_ARRAY_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }
      
      return (R) INT_TYPE;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String object_class=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String method_name=(String)n.f2.accept(this, null);
      n.f3.accept(this, argu); if(type_error) return null;

      /* Check to see if the method can be called from the current context */
      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         function_signature signature=get_function_signature(method_name, object_class);
         if(type_error) return null;

         String calling_class=((String)argu).split("\\s+")[0];
         if(calling_class.compareTo(object_class)!=0) {
            if(is_descendent_of(calling_class, object_class)) {
               if(signature.access_type.compareTo(PRIVATE)==0) {
                  type_error=true;
                  ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
                  return null;
               }
            } else {
               if(signature.access_type.compareTo(PUBLIC)!=0) {
                  type_error=true;
                  ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
                  return null;
               }
            }
         }

         expression_list.add(null);
      }
      n.f4.accept(this, (A)(((String)argu) + " add_to_expression_list")); if(type_error) return null;
      
      n.f5.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         function_signature signature=get_function_signature(method_name, object_class);
         int parameter_count=signature.parameter_list.size();

         // ;// System.out.println(signature.parameter_list.size() + " ^ " + expression_list.size());
         // if(signature.parameter_list.size() > expression_list.size()) {
         //    type_error=true;
         //    ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
         //    ;// System.out.println(signature.parameter_list.toString());
         //    ;// System.out.println(expression_list.toString());
         //    return null;
         // }

         for(int i=0; i<parameter_count; i++) {
            String t1=signature.parameter_list.get(i);
            String t2=expression_list.get(expression_list.size() - parameter_count + i);
            if(t2==null || !is_descendent_of(t2, t1)) {
               type_error=true;
               ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
               ;// System.out.println(method_name + "=> " + t1 + " " + t2);
               return null;
            }
         }

         if(!type_error) {
            for(int i=0; i<parameter_count; i++)
               expression_list.remove(expression_list.size()-1);

            if(expression_list.size()==0 || expression_list.get(expression_list.size()-1)!=null) {
               type_error=true;
               ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
               return null;
            }

            expression_list.remove(expression_list.size()-1);
         }

         return (R) signature.return_type;
      }

      return _ret;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "?"
    * f2 -> PrimaryExpression()
    * f3 -> ":"
    * f4 -> PrimaryExpression()
    */
   public R visit(TernaryExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      String condition_type=(String)n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      String option1_type=(String)n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;
      String option2_type=(String)n.f4.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(condition_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(condition_type);
            return null;
         }
         String lub=least_upper_bound(option1_type, option2_type);
         if(lub==null) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            ;// System.out.println(option1_type + "-" + option2_type);
            return null;
         }
         return (R) lub;
      }

      return _ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      if(argu==null || ((String)argu).split("\\s+").length==2) {
         argu=(A) (argu + " variable_type");
      }

      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return (R) INT_TYPE;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return (R) BOOLEAN_TYPE;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;
      return (R) BOOLEAN_TYPE;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         if(argu==null)
            return _ret;

         String[] parts=((String)argu).split("\\s+");
         if(parts[parts.length-1].compareTo("variable_type")!=0)
            return _ret;
         
         String variable_type=get_variable_type((String)_ret, parts[0] + " " + parts[1]);
         return (R)variable_type;
      }

      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=n.f0.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         String[] parts=((String)argu).split("\\s+");
         return (R) parts[0];
      }

      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0 && argu!=null) {
         String[] parts=((String)argu).split("\\s+");
         ;// System.out.println(argu);
         if(parts[parts.length-1].compareTo("variable_type")==0) {
            String new_argu="";
            for(int i=0; i<parts.length-1; i++)
               new_argu=new_argu + parts[i] + " ";
            argu=(A) new_argu;
         }
      }

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      n.f2.accept(this, argu); if(type_error) return null;
      String data_type=(String)n.f3.accept(this, argu); if(type_error) return null;
      n.f4.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that Expression is an int */
         if(data_type.compareTo(INT_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) INT_ARRAY_TYPE;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0 && argu!=null) {
         String[] parts=((String)argu).split("\\s+");
         ;// System.out.println(argu);
         if(parts[parts.length-1].compareTo("variable_type")==0) {
            String new_argu="";
            for(int i=0; i<parts.length-1; i++)
               new_argu=new_argu + parts[i] + " ";
            argu=(A) new_argu;
         }
      }

      n.f0.accept(this, argu); if(type_error) return null;

      /* By passing null argu we ensure it will definitely return just value of identifier rather than type */
      String data_type=(String)n.f1.accept(this, null);

      n.f2.accept(this, argu); if(type_error) return null;
      n.f3.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that Identifier is a class name */
         if(!classes.containsKey(data_type)) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }
      
      return (R) data_type;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0 && argu!=null) {
         String[] parts=((String)argu).split("\\s+");
         ;// System.out.println(argu);
         if(parts[parts.length-1].compareTo("variable_type")==0) {
            String new_argu="";
            for(int i=0; i<parts.length-1; i++)
               new_argu=new_argu + parts[i] + " ";
            argu=(A) new_argu;
         }
      }

      n.f0.accept(this, argu); if(type_error) return null;
      String data_type=(String)n.f1.accept(this, argu); if(type_error) return null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0) {
         /* Ensure that Expression is of boolean type */
         if(data_type.compareTo(BOOLEAN_TYPE)!=0) {
            type_error=true;
            ;// System.out.println(new Object(){}.getClass().getEnclosingMethod().getParameters()[0] +  "<--ERROR-->" + argu);
            return null;
         }
      }

      return (R) data_type;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      if(phase.compareTo(PARSE_AND_TYPE_CHECK)==0 && argu!=null) {
         String[] parts=((String)argu).split("\\s+");
         ;// System.out.println(argu);
         if(parts[parts.length-1].compareTo("variable_type")==0) {
            String new_argu="";
            for(int i=0; i<parts.length-1; i++)
               new_argu=new_argu + parts[i] + " ";
            argu=(A) new_argu;
         }
      }

      n.f0.accept(this, argu); if(type_error) return null;
      String data_type=(String)n.f1.accept(this, argu); if(type_error) return null;
      n.f2.accept(this, argu); if(type_error) return null;

      /* Resulting type is that of the Expression itself */
      return (R) data_type;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public R visit(IdentifierList n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(IdentifierRest n, A argu) {
      if(type_error) return null;
      Method mt = new Object(){}.getClass().getEnclosingMethod();
      ;// System.out.println(mt.getParameters()[0] +  "--" + argu);
      R _ret=null;

      n.f0.accept(this, argu); if(type_error) return null;
      n.f1.accept(this, argu); if(type_error) return null;
      return _ret;
   }

}
